{"version":3,"file":"client.temp.ts","sources":["https://deno.land/x/dropper@1.10.0/src/helpers.ts","https://deno.land/std@0.83.0/encoding/utf8.ts","https://deno.land/std@0.83.0/io/bufio.ts","https://deno.land/std@0.83.0/http/http_status.ts","https://raw.githubusercontent.com/vadzim/thenable-reject/master/src/thenable-reject.ts","https://raw.githubusercontent.com/denyncrawford/websocket-iterator/master/src/websocket-iterator.ts","https://deno.land/std@0.83.0/io/ioutil.ts","https://deno.land/std@0.83.0/ws/mod.ts","https://deno.land/std@0.83.0/uuid/_common.ts","https://deno.land/std@0.83.0/uuid/v4.ts","https://deno.land/std/fmt/colors.ts","https://deno.land/std/testing/_diff.ts","https://deno.land/std/_util/assert.ts","https://deno.land/std/node/_utils.ts","https://deno.land/std/node/events.ts","https://deno.land/x/dropper@1.10.0/src/browser.ts","../src/client.ts"],"sourcesContent":["import { hasOwnProperty } from 'https://deno.land/std@0.83.0/_util/has_own_property.ts';\nexport function hasJsonStructure(str) {\n    if (typeof str !== 'string') return false;\n    try {\n        const result = JSON.parse(str);\n        const type = Object.prototype.toString.call(result);\n        return type === '[object Object]' || type === '[object Array]';\n    } catch (err) {\n        return false;\n    }\n}\nexport function isArray(str) {\n    if (typeof str !== 'string') return false;\n    try {\n        const result = JSON.parse(str);\n        const type = Object.prototype.toString.call(result);\n        return type === '[object Array]';\n    } catch (err) {\n        return false;\n    }\n}\nexport function connectWebSocket(endpoint, id) {\n    return new Promise(function(resolve, reject) {\n        const url = new URL(endpoint);\n        const { hostname , protocol , port , pathname  } = url;\n        let p;\n        if (protocol === 'http:') p = 'ws://';\n        else if (protocol === 'https:') p = 'wss://';\n        else if (protocol === 'ws:' || protocol === 'wss:') p = protocol + '//';\n        else throw new Error(\"ws: unsupported protocol: \" + url.protocol);\n        const uri = `${p + hostname}:${port + pathname}?id=${id}`;\n        let socket = new WebSocket(uri);\n        socket.onopen = ()=>{\n            resolve(socket);\n        };\n        socket.onerror = (err)=>{\n            reject(err);\n        };\n    });\n}\nexport function isWebSocketPongEvent(a) {\n    let newArr = typeof a === 'string' && isArray(a) ? JSON.parse(a).map((e)=>{\n        if (typeof e !== \"object\") return e;\n        else return new Uint8Array(1);\n    }) : a;\n    return Array.isArray(newArr) && newArr[0] === \"pong\" && newArr[1] instanceof Uint8Array;\n}\nexport function isWebSocketPingEvent(a) {\n    let newArr = typeof a === 'string' && isArray(a) ? JSON.parse(a).map((e)=>{\n        if (typeof e !== \"object\") return e;\n        else return new Uint8Array(1);\n    }) : a;\n    return Array.isArray(newArr) && newArr[0] === \"ping\" && newArr[1] instanceof Uint8Array;\n}\nexport function isWebSocketCloseEvent(a) {\n    return hasOwnProperty(a, \"code\");\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n/** A default TextEncoder instance */ export const encoder = new TextEncoder();\n/** Shorthand for new TextEncoder().encode() */ export function encode(input) {\n    return encoder.encode(input);\n}\n/** A default TextDecoder instance */ export const decoder = new TextDecoder();\n/** Shorthand for new TextDecoder().decode() */ export function decode(input) {\n    return decoder.decode(input);\n}\n","import { copy } from \"../bytes/mod.ts\";\nimport { assert } from \"../_util/assert.ts\";\nconst DEFAULT_BUF_SIZE = 4096;\nconst MIN_BUF_SIZE = 16;\nconst MAX_CONSECUTIVE_EMPTY_READS = 100;\nconst CR = \"\\r\".charCodeAt(0);\nconst LF = \"\\n\".charCodeAt(0);\nexport class BufferFullError extends Error {\n    name = \"BufferFullError\";\n    constructor(partial){\n        super(\"Buffer full\");\n        this.partial = partial;\n    }\n}\nexport class PartialReadError extends Deno.errors.UnexpectedEof {\n    name = \"PartialReadError\";\n    constructor(){\n        super(\"Encountered UnexpectedEof, data only partially read\");\n    }\n}\n/** BufReader implements buffering for a Reader object. */ export class BufReader {\n    r = 0;\n    w = 0;\n    eof = false;\n    // private lastByte: number;\n    // private lastCharSize: number;\n    /** return new BufReader unless r is BufReader */ static create(r, size = DEFAULT_BUF_SIZE) {\n        return r instanceof BufReader ? r : new BufReader(r, size);\n    }\n    constructor(rd, size = DEFAULT_BUF_SIZE){\n        if (size < MIN_BUF_SIZE) {\n            size = MIN_BUF_SIZE;\n        }\n        this._reset(new Uint8Array(size), rd);\n    }\n    /** Returns the size of the underlying buffer in bytes. */ size() {\n        return this.buf.byteLength;\n    }\n    buffered() {\n        return this.w - this.r;\n    }\n    // Reads a new chunk into the buffer.\n    async _fill() {\n        // Slide existing data to beginning.\n        if (this.r > 0) {\n            this.buf.copyWithin(0, this.r, this.w);\n            this.w -= this.r;\n            this.r = 0;\n        }\n        if (this.w >= this.buf.byteLength) {\n            throw Error(\"bufio: tried to fill full buffer\");\n        }\n        // Read new data: try a limited number of times.\n        for(let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--){\n            const rr = await this.rd.read(this.buf.subarray(this.w));\n            if (rr === null) {\n                this.eof = true;\n                return;\n            }\n            assert(rr >= 0, \"negative read\");\n            this.w += rr;\n            if (rr > 0) {\n                return;\n            }\n        }\n        throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);\n    }\n    /** Discards any buffered data, resets all state, and switches\n   * the buffered reader to read from r.\n   */ reset(r) {\n        this._reset(this.buf, r);\n    }\n    _reset(buf, rd) {\n        this.buf = buf;\n        this.rd = rd;\n        this.eof = false;\n    }\n    /** reads data into p.\n   * It returns the number of bytes read into p.\n   * The bytes are taken from at most one Read on the underlying Reader,\n   * hence n may be less than len(p).\n   * To read exactly len(p) bytes, use io.ReadFull(b, p).\n   */ async read(p) {\n        let rr = p.byteLength;\n        if (p.byteLength === 0) return rr;\n        if (this.r === this.w) {\n            if (p.byteLength >= this.buf.byteLength) {\n                // Large read, empty buffer.\n                // Read directly into p to avoid copy.\n                const rr = await this.rd.read(p);\n                const nread = rr ?? 0;\n                assert(nread >= 0, \"negative read\");\n                // if (rr.nread > 0) {\n                //   this.lastByte = p[rr.nread - 1];\n                //   this.lastCharSize = -1;\n                // }\n                return rr;\n            }\n            // One read.\n            // Do not use this.fill, which will loop.\n            this.r = 0;\n            this.w = 0;\n            rr = await this.rd.read(this.buf);\n            if (rr === 0 || rr === null) return rr;\n            assert(rr >= 0, \"negative read\");\n            this.w += rr;\n        }\n        // copy as much as we can\n        const copied = copy(this.buf.subarray(this.r, this.w), p, 0);\n        this.r += copied;\n        // this.lastByte = this.buf[this.r - 1];\n        // this.lastCharSize = -1;\n        return copied;\n    }\n    /** reads exactly `p.length` bytes into `p`.\n   *\n   * If successful, `p` is returned.\n   *\n   * If the end of the underlying stream has been reached, and there are no more\n   * bytes available in the buffer, `readFull()` returns `null` instead.\n   *\n   * An error is thrown if some bytes could be read, but not enough to fill `p`\n   * entirely before the underlying stream reported an error or EOF. Any error\n   * thrown will have a `partial` property that indicates the slice of the\n   * buffer that has been successfully filled with data.\n   *\n   * Ported from https://golang.org/pkg/io/#ReadFull\n   */ async readFull(p) {\n        let bytesRead = 0;\n        while(bytesRead < p.length){\n            try {\n                const rr = await this.read(p.subarray(bytesRead));\n                if (rr === null) {\n                    if (bytesRead === 0) {\n                        return null;\n                    } else {\n                        throw new PartialReadError();\n                    }\n                }\n                bytesRead += rr;\n            } catch (err) {\n                err.partial = p.subarray(0, bytesRead);\n                throw err;\n            }\n        }\n        return p;\n    }\n    /** Returns the next byte [0, 255] or `null`. */ async readByte() {\n        while(this.r === this.w){\n            if (this.eof) return null;\n            await this._fill(); // buffer is empty.\n        }\n        const c = this.buf[this.r];\n        this.r++;\n        // this.lastByte = c;\n        return c;\n    }\n    /** readString() reads until the first occurrence of delim in the input,\n   * returning a string containing the data up to and including the delimiter.\n   * If ReadString encounters an error before finding a delimiter,\n   * it returns the data read before the error and the error itself\n   * (often `null`).\n   * ReadString returns err != nil if and only if the returned data does not end\n   * in delim.\n   * For simple uses, a Scanner may be more convenient.\n   */ async readString(delim) {\n        if (delim.length !== 1) {\n            throw new Error(\"Delimiter should be a single character\");\n        }\n        const buffer = await this.readSlice(delim.charCodeAt(0));\n        if (buffer === null) return null;\n        return new TextDecoder().decode(buffer);\n    }\n    /** `readLine()` is a low-level line-reading primitive. Most callers should\n   * use `readString('\\n')` instead or use a Scanner.\n   *\n   * `readLine()` tries to return a single line, not including the end-of-line\n   * bytes. If the line was too long for the buffer then `more` is set and the\n   * beginning of the line is returned. The rest of the line will be returned\n   * from future calls. `more` will be false when returning the last fragment\n   * of the line. The returned buffer is only valid until the next call to\n   * `readLine()`.\n   *\n   * The text returned from ReadLine does not include the line end (\"\\r\\n\" or\n   * \"\\n\").\n   *\n   * When the end of the underlying stream is reached, the final bytes in the\n   * stream are returned. No indication or error is given if the input ends\n   * without a final line end. When there are no more trailing bytes to read,\n   * `readLine()` returns `null`.\n   *\n   * Calling `unreadByte()` after `readLine()` will always unread the last byte\n   * read (possibly a character belonging to the line end) even if that byte is\n   * not part of the line returned by `readLine()`.\n   */ async readLine() {\n        let line;\n        try {\n            line = await this.readSlice(LF);\n        } catch (err) {\n            let { partial  } = err;\n            assert(partial instanceof Uint8Array, \"bufio: caught error from `readSlice()` without `partial` property\");\n            // Don't throw if `readSlice()` failed with `BufferFullError`, instead we\n            // just return whatever is available and set the `more` flag.\n            if (!(err instanceof BufferFullError)) {\n                throw err;\n            }\n            // Handle the case where \"\\r\\n\" straddles the buffer.\n            if (!this.eof && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {\n                // Put the '\\r' back on buf and drop it from line.\n                // Let the next call to ReadLine check for \"\\r\\n\".\n                assert(this.r > 0, \"bufio: tried to rewind past start of buffer\");\n                this.r--;\n                partial = partial.subarray(0, partial.byteLength - 1);\n            }\n            return {\n                line: partial,\n                more: !this.eof\n            };\n        }\n        if (line === null) {\n            return null;\n        }\n        if (line.byteLength === 0) {\n            return {\n                line,\n                more: false\n            };\n        }\n        if (line[line.byteLength - 1] == LF) {\n            let drop = 1;\n            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {\n                drop = 2;\n            }\n            line = line.subarray(0, line.byteLength - drop);\n        }\n        return {\n            line,\n            more: false\n        };\n    }\n    /** `readSlice()` reads until the first occurrence of `delim` in the input,\n   * returning a slice pointing at the bytes in the buffer. The bytes stop\n   * being valid at the next read.\n   *\n   * If `readSlice()` encounters an error before finding a delimiter, or the\n   * buffer fills without finding a delimiter, it throws an error with a\n   * `partial` property that contains the entire buffer.\n   *\n   * If `readSlice()` encounters the end of the underlying stream and there are\n   * any bytes left in the buffer, the rest of the buffer is returned. In other\n   * words, EOF is always treated as a delimiter. Once the buffer is empty,\n   * it returns `null`.\n   *\n   * Because the data returned from `readSlice()` will be overwritten by the\n   * next I/O operation, most clients should use `readString()` instead.\n   */ async readSlice(delim) {\n        let s = 0; // search start index\n        let slice;\n        while(true){\n            // Search buffer.\n            let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);\n            if (i >= 0) {\n                i += s;\n                slice = this.buf.subarray(this.r, this.r + i + 1);\n                this.r += i + 1;\n                break;\n            }\n            // EOF?\n            if (this.eof) {\n                if (this.r === this.w) {\n                    return null;\n                }\n                slice = this.buf.subarray(this.r, this.w);\n                this.r = this.w;\n                break;\n            }\n            // Buffer full?\n            if (this.buffered() >= this.buf.byteLength) {\n                this.r = this.w;\n                // #4521 The internal buffer should not be reused across reads because it causes corruption of data.\n                const oldbuf = this.buf;\n                const newbuf = this.buf.slice(0);\n                this.buf = newbuf;\n                throw new BufferFullError(oldbuf);\n            }\n            s = this.w - this.r; // do not rescan area we scanned before\n            // Buffer is not full.\n            try {\n                await this._fill();\n            } catch (err) {\n                err.partial = slice;\n                throw err;\n            }\n        }\n        // Handle last byte, if any.\n        // const i = slice.byteLength - 1;\n        // if (i >= 0) {\n        //   this.lastByte = slice[i];\n        //   this.lastCharSize = -1\n        // }\n        return slice;\n    }\n    /** `peek()` returns the next `n` bytes without advancing the reader. The\n   * bytes stop being valid at the next read call.\n   *\n   * When the end of the underlying stream is reached, but there are unread\n   * bytes left in the buffer, those bytes are returned. If there are no bytes\n   * left in the buffer, it returns `null`.\n   *\n   * If an error is encountered before `n` bytes are available, `peek()` throws\n   * an error with the `partial` property set to a slice of the buffer that\n   * contains the bytes that were available before the error occurred.\n   */ async peek(n) {\n        if (n < 0) {\n            throw Error(\"negative count\");\n        }\n        let avail = this.w - this.r;\n        while(avail < n && avail < this.buf.byteLength && !this.eof){\n            try {\n                await this._fill();\n            } catch (err) {\n                err.partial = this.buf.subarray(this.r, this.w);\n                throw err;\n            }\n            avail = this.w - this.r;\n        }\n        if (avail === 0 && this.eof) {\n            return null;\n        } else if (avail < n && this.eof) {\n            return this.buf.subarray(this.r, this.r + avail);\n        } else if (avail < n) {\n            throw new BufferFullError(this.buf.subarray(this.r, this.w));\n        }\n        return this.buf.subarray(this.r, this.r + n);\n    }\n}\nclass AbstractBufBase {\n    usedBufferBytes = 0;\n    err = null;\n    /** Size returns the size of the underlying buffer in bytes. */ size() {\n        return this.buf.byteLength;\n    }\n    /** Returns how many bytes are unused in the buffer. */ available() {\n        return this.buf.byteLength - this.usedBufferBytes;\n    }\n    /** buffered returns the number of bytes that have been written into the\n   * current buffer.\n   */ buffered() {\n        return this.usedBufferBytes;\n    }\n}\n/** BufWriter implements buffering for an deno.Writer object.\n * If an error occurs writing to a Writer, no more data will be\n * accepted and all subsequent writes, and flush(), will return the error.\n * After all data has been written, the client should call the\n * flush() method to guarantee all data has been forwarded to\n * the underlying deno.Writer.\n */ export class BufWriter extends AbstractBufBase {\n    /** return new BufWriter unless writer is BufWriter */ static create(writer, size = DEFAULT_BUF_SIZE) {\n        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);\n    }\n    constructor(writer, size = DEFAULT_BUF_SIZE){\n        super();\n        this.writer = writer;\n        if (size <= 0) {\n            size = DEFAULT_BUF_SIZE;\n        }\n        this.buf = new Uint8Array(size);\n    }\n    /** Discards any unflushed buffered data, clears any error, and\n   * resets buffer to write its output to w.\n   */ reset(w) {\n        this.err = null;\n        this.usedBufferBytes = 0;\n        this.writer = w;\n    }\n    /** Flush writes any buffered data to the underlying io.Writer. */ async flush() {\n        if (this.err !== null) throw this.err;\n        if (this.usedBufferBytes === 0) return;\n        try {\n            await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));\n        } catch (e) {\n            this.err = e;\n            throw e;\n        }\n        this.buf = new Uint8Array(this.buf.length);\n        this.usedBufferBytes = 0;\n    }\n    /** Writes the contents of `data` into the buffer.  If the contents won't fully\n   * fit into the buffer, those bytes that can are copied into the buffer, the\n   * buffer is the flushed to the writer and the remaining bytes are copied into\n   * the now empty buffer.\n   *\n   * @return the number of bytes written to the buffer.\n   */ async write(data) {\n        if (this.err !== null) throw this.err;\n        if (data.length === 0) return 0;\n        let totalBytesWritten = 0;\n        let numBytesWritten = 0;\n        while(data.byteLength > this.available()){\n            if (this.buffered() === 0) {\n                // Large write, empty buffer.\n                // Write directly from data to avoid copy.\n                try {\n                    numBytesWritten = await this.writer.write(data);\n                } catch (e) {\n                    this.err = e;\n                    throw e;\n                }\n            } else {\n                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);\n                this.usedBufferBytes += numBytesWritten;\n                await this.flush();\n            }\n            totalBytesWritten += numBytesWritten;\n            data = data.subarray(numBytesWritten);\n        }\n        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);\n        this.usedBufferBytes += numBytesWritten;\n        totalBytesWritten += numBytesWritten;\n        return totalBytesWritten;\n    }\n}\n/** BufWriterSync implements buffering for a deno.WriterSync object.\n * If an error occurs writing to a WriterSync, no more data will be\n * accepted and all subsequent writes, and flush(), will return the error.\n * After all data has been written, the client should call the\n * flush() method to guarantee all data has been forwarded to\n * the underlying deno.WriterSync.\n */ export class BufWriterSync extends AbstractBufBase {\n    /** return new BufWriterSync unless writer is BufWriterSync */ static create(writer, size = DEFAULT_BUF_SIZE) {\n        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);\n    }\n    constructor(writer, size = DEFAULT_BUF_SIZE){\n        super();\n        this.writer = writer;\n        if (size <= 0) {\n            size = DEFAULT_BUF_SIZE;\n        }\n        this.buf = new Uint8Array(size);\n    }\n    /** Discards any unflushed buffered data, clears any error, and\n   * resets buffer to write its output to w.\n   */ reset(w) {\n        this.err = null;\n        this.usedBufferBytes = 0;\n        this.writer = w;\n    }\n    /** Flush writes any buffered data to the underlying io.WriterSync. */ flush() {\n        if (this.err !== null) throw this.err;\n        if (this.usedBufferBytes === 0) return;\n        try {\n            Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));\n        } catch (e) {\n            this.err = e;\n            throw e;\n        }\n        this.buf = new Uint8Array(this.buf.length);\n        this.usedBufferBytes = 0;\n    }\n    /** Writes the contents of `data` into the buffer.  If the contents won't fully\n   * fit into the buffer, those bytes that can are copied into the buffer, the\n   * buffer is the flushed to the writer and the remaining bytes are copied into\n   * the now empty buffer.\n   *\n   * @return the number of bytes written to the buffer.\n   */ writeSync(data) {\n        if (this.err !== null) throw this.err;\n        if (data.length === 0) return 0;\n        let totalBytesWritten = 0;\n        let numBytesWritten = 0;\n        while(data.byteLength > this.available()){\n            if (this.buffered() === 0) {\n                // Large write, empty buffer.\n                // Write directly from data to avoid copy.\n                try {\n                    numBytesWritten = this.writer.writeSync(data);\n                } catch (e) {\n                    this.err = e;\n                    throw e;\n                }\n            } else {\n                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);\n                this.usedBufferBytes += numBytesWritten;\n                this.flush();\n            }\n            totalBytesWritten += numBytesWritten;\n            data = data.subarray(numBytesWritten);\n        }\n        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);\n        this.usedBufferBytes += numBytesWritten;\n        totalBytesWritten += numBytesWritten;\n        return totalBytesWritten;\n    }\n}\n/** Generate longest proper prefix which is also suffix array. */ function createLPS(pat) {\n    const lps = new Uint8Array(pat.length);\n    lps[0] = 0;\n    let prefixEnd = 0;\n    let i = 1;\n    while(i < lps.length){\n        if (pat[i] == pat[prefixEnd]) {\n            prefixEnd++;\n            lps[i] = prefixEnd;\n            i++;\n        } else if (prefixEnd === 0) {\n            lps[i] = 0;\n            i++;\n        } else {\n            prefixEnd = pat[prefixEnd - 1];\n        }\n    }\n    return lps;\n}\n/** Read delimited bytes from a Reader. */ export async function* readDelim(reader, delim) {\n    // Avoid unicode problems\n    const delimLen = delim.length;\n    const delimLPS = createLPS(delim);\n    let inputBuffer = new Deno.Buffer();\n    const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));\n    // Modified KMP\n    let inspectIndex = 0;\n    let matchIndex = 0;\n    while(true){\n        const result = await reader.read(inspectArr);\n        if (result === null) {\n            // Yield last chunk.\n            yield inputBuffer.bytes();\n            return;\n        }\n        if (result < 0) {\n            // Discard all remaining and silently fail.\n            return;\n        }\n        const sliceRead = inspectArr.subarray(0, result);\n        await Deno.writeAll(inputBuffer, sliceRead);\n        let sliceToProcess = inputBuffer.bytes();\n        while(inspectIndex < sliceToProcess.length){\n            if (sliceToProcess[inspectIndex] === delim[matchIndex]) {\n                inspectIndex++;\n                matchIndex++;\n                if (matchIndex === delimLen) {\n                    // Full match\n                    const matchEnd = inspectIndex - delimLen;\n                    const readyBytes = sliceToProcess.subarray(0, matchEnd);\n                    // Copy\n                    const pendingBytes = sliceToProcess.slice(inspectIndex);\n                    yield readyBytes;\n                    // Reset match, different from KMP.\n                    sliceToProcess = pendingBytes;\n                    inspectIndex = 0;\n                    matchIndex = 0;\n                }\n            } else {\n                if (matchIndex === 0) {\n                    inspectIndex++;\n                } else {\n                    matchIndex = delimLPS[matchIndex - 1];\n                }\n            }\n        }\n        // Keep inspectIndex and matchIndex.\n        inputBuffer = new Deno.Buffer(sliceToProcess);\n    }\n}\n/** Read delimited strings from a Reader. */ export async function* readStringDelim(reader, delim) {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    for await (const chunk of readDelim(reader, encoder.encode(delim))){\n        yield decoder.decode(chunk);\n    }\n}\n/** Read strings line-by-line from a Reader. */ export async function* readLines(reader) {\n    for await (let chunk of readStringDelim(reader, \"\\n\")){\n        // Finding a CR at the end of the line is evidence of a\n        // \"\\r\\n\" at the end of the line. The \"\\r\" part should be\n        // removed too.\n        if (chunk.endsWith(\"\\r\")) {\n            chunk = chunk.slice(0, -1);\n        }\n        yield chunk;\n    }\n}\n","export var Status;\n(function(Status) {\n    Status[Status[/** RFC 7231, 6.2.1 */ \"Continue\"] = 100] = \"Continue\";\n    Status[Status[/** RFC 7231, 6.2.2 */ \"SwitchingProtocols\"] = 101] = \"SwitchingProtocols\";\n    Status[Status[/** RFC 2518, 10.1 */ \"Processing\"] = 102] = \"Processing\";\n    Status[Status[/** RFC 8297 **/ \"EarlyHints\"] = 103] = \"EarlyHints\";\n    Status[Status[/** RFC 7231, 6.3.1 */ \"OK\"] = 200] = \"OK\";\n    Status[Status[/** RFC 7231, 6.3.2 */ \"Created\"] = 201] = \"Created\";\n    Status[Status[/** RFC 7231, 6.3.3 */ \"Accepted\"] = 202] = \"Accepted\";\n    Status[Status[/** RFC 7231, 6.3.4 */ \"NonAuthoritativeInfo\"] = 203] = \"NonAuthoritativeInfo\";\n    Status[Status[/** RFC 7231, 6.3.5 */ \"NoContent\"] = 204] = \"NoContent\";\n    Status[Status[/** RFC 7231, 6.3.6 */ \"ResetContent\"] = 205] = \"ResetContent\";\n    Status[Status[/** RFC 7233, 4.1 */ \"PartialContent\"] = 206] = \"PartialContent\";\n    Status[Status[/** RFC 4918, 11.1 */ \"MultiStatus\"] = 207] = \"MultiStatus\";\n    Status[Status[/** RFC 5842, 7.1 */ \"AlreadyReported\"] = 208] = \"AlreadyReported\";\n    Status[Status[/** RFC 3229, 10.4.1 */ \"IMUsed\"] = 226] = \"IMUsed\";\n    Status[Status[/** RFC 7231, 6.4.1 */ \"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    Status[Status[/** RFC 7231, 6.4.2 */ \"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    Status[Status[/** RFC 7231, 6.4.3 */ \"Found\"] = 302] = \"Found\";\n    Status[Status[/** RFC 7231, 6.4.4 */ \"SeeOther\"] = 303] = \"SeeOther\";\n    Status[Status[/** RFC 7232, 4.1 */ \"NotModified\"] = 304] = \"NotModified\";\n    Status[Status[/** RFC 7231, 6.4.5 */ \"UseProxy\"] = 305] = \"UseProxy\";\n    Status[Status[/** RFC 7231, 6.4.7 */ \"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    Status[Status[/** RFC 7538, 3 */ \"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    Status[Status[/** RFC 7231, 6.5.1 */ \"BadRequest\"] = 400] = \"BadRequest\";\n    Status[Status[/** RFC 7235, 3.1 */ \"Unauthorized\"] = 401] = \"Unauthorized\";\n    Status[Status[/** RFC 7231, 6.5.2 */ \"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    Status[Status[/** RFC 7231, 6.5.3 */ \"Forbidden\"] = 403] = \"Forbidden\";\n    Status[Status[/** RFC 7231, 6.5.4 */ \"NotFound\"] = 404] = \"NotFound\";\n    Status[Status[/** RFC 7231, 6.5.5 */ \"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    Status[Status[/** RFC 7231, 6.5.6 */ \"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    Status[Status[/** RFC 7235, 3.2 */ \"ProxyAuthRequired\"] = 407] = \"ProxyAuthRequired\";\n    Status[Status[/** RFC 7231, 6.5.7 */ \"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    Status[Status[/** RFC 7231, 6.5.8 */ \"Conflict\"] = 409] = \"Conflict\";\n    Status[Status[/** RFC 7231, 6.5.9 */ \"Gone\"] = 410] = \"Gone\";\n    Status[Status[/** RFC 7231, 6.5.10 */ \"LengthRequired\"] = 411] = \"LengthRequired\";\n    Status[Status[/** RFC 7232, 4.2 */ \"PreconditionFailed\"] = 412] = \"PreconditionFailed\";\n    Status[Status[/** RFC 7231, 6.5.11 */ \"RequestEntityTooLarge\"] = 413] = \"RequestEntityTooLarge\";\n    Status[Status[/** RFC 7231, 6.5.12 */ \"RequestURITooLong\"] = 414] = \"RequestURITooLong\";\n    Status[Status[/** RFC 7231, 6.5.13 */ \"UnsupportedMediaType\"] = 415] = \"UnsupportedMediaType\";\n    Status[Status[/** RFC 7233, 4.4 */ \"RequestedRangeNotSatisfiable\"] = 416] = \"RequestedRangeNotSatisfiable\";\n    Status[Status[/** RFC 7231, 6.5.14 */ \"ExpectationFailed\"] = 417] = \"ExpectationFailed\";\n    Status[Status[/** RFC 7168, 2.3.3 */ \"Teapot\"] = 418] = \"Teapot\";\n    Status[Status[/** RFC 7540, 9.1.2 */ \"MisdirectedRequest\"] = 421] = \"MisdirectedRequest\";\n    Status[Status[/** RFC 4918, 11.2 */ \"UnprocessableEntity\"] = 422] = \"UnprocessableEntity\";\n    Status[Status[/** RFC 4918, 11.3 */ \"Locked\"] = 423] = \"Locked\";\n    Status[Status[/** RFC 4918, 11.4 */ \"FailedDependency\"] = 424] = \"FailedDependency\";\n    Status[Status[/** RFC 8470, 5.2 */ \"TooEarly\"] = 425] = \"TooEarly\";\n    Status[Status[/** RFC 7231, 6.5.15 */ \"UpgradeRequired\"] = 426] = \"UpgradeRequired\";\n    Status[Status[/** RFC 6585, 3 */ \"PreconditionRequired\"] = 428] = \"PreconditionRequired\";\n    Status[Status[/** RFC 6585, 4 */ \"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    Status[Status[/** RFC 6585, 5 */ \"RequestHeaderFieldsTooLarge\"] = 431] = \"RequestHeaderFieldsTooLarge\";\n    Status[Status[/** RFC 7725, 3 */ \"UnavailableForLegalReasons\"] = 451] = \"UnavailableForLegalReasons\";\n    Status[Status[/** RFC 7231, 6.6.1 */ \"InternalServerError\"] = 500] = \"InternalServerError\";\n    Status[Status[/** RFC 7231, 6.6.2 */ \"NotImplemented\"] = 501] = \"NotImplemented\";\n    Status[Status[/** RFC 7231, 6.6.3 */ \"BadGateway\"] = 502] = \"BadGateway\";\n    Status[Status[/** RFC 7231, 6.6.4 */ \"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    Status[Status[/** RFC 7231, 6.6.5 */ \"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n    Status[Status[/** RFC 7231, 6.6.6 */ \"HTTPVersionNotSupported\"] = 505] = \"HTTPVersionNotSupported\";\n    Status[Status[/** RFC 2295, 8.1 */ \"VariantAlsoNegotiates\"] = 506] = \"VariantAlsoNegotiates\";\n    Status[Status[/** RFC 4918, 11.5 */ \"InsufficientStorage\"] = 507] = \"InsufficientStorage\";\n    Status[Status[/** RFC 5842, 7.2 */ \"LoopDetected\"] = 508] = \"LoopDetected\";\n    Status[Status[/** RFC 2774, 7 */ \"NotExtended\"] = 510] = \"NotExtended\";\n    Status[Status[/** RFC 6585, 6 */ \"NetworkAuthenticationRequired\"] = 511] = \"NetworkAuthenticationRequired\";\n})(Status || (Status = {\n}));\nexport const STATUS_TEXT = new Map([\n    [\n        Status.Continue,\n        \"Continue\"\n    ],\n    [\n        Status.SwitchingProtocols,\n        \"Switching Protocols\"\n    ],\n    [\n        Status.Processing,\n        \"Processing\"\n    ],\n    [\n        Status.EarlyHints,\n        \"Early Hints\"\n    ],\n    [\n        Status.OK,\n        \"OK\"\n    ],\n    [\n        Status.Created,\n        \"Created\"\n    ],\n    [\n        Status.Accepted,\n        \"Accepted\"\n    ],\n    [\n        Status.NonAuthoritativeInfo,\n        \"Non-Authoritative Information\"\n    ],\n    [\n        Status.NoContent,\n        \"No Content\"\n    ],\n    [\n        Status.ResetContent,\n        \"Reset Content\"\n    ],\n    [\n        Status.PartialContent,\n        \"Partial Content\"\n    ],\n    [\n        Status.MultiStatus,\n        \"Multi-Status\"\n    ],\n    [\n        Status.AlreadyReported,\n        \"Already Reported\"\n    ],\n    [\n        Status.IMUsed,\n        \"IM Used\"\n    ],\n    [\n        Status.MultipleChoices,\n        \"Multiple Choices\"\n    ],\n    [\n        Status.MovedPermanently,\n        \"Moved Permanently\"\n    ],\n    [\n        Status.Found,\n        \"Found\"\n    ],\n    [\n        Status.SeeOther,\n        \"See Other\"\n    ],\n    [\n        Status.NotModified,\n        \"Not Modified\"\n    ],\n    [\n        Status.UseProxy,\n        \"Use Proxy\"\n    ],\n    [\n        Status.TemporaryRedirect,\n        \"Temporary Redirect\"\n    ],\n    [\n        Status.PermanentRedirect,\n        \"Permanent Redirect\"\n    ],\n    [\n        Status.BadRequest,\n        \"Bad Request\"\n    ],\n    [\n        Status.Unauthorized,\n        \"Unauthorized\"\n    ],\n    [\n        Status.PaymentRequired,\n        \"Payment Required\"\n    ],\n    [\n        Status.Forbidden,\n        \"Forbidden\"\n    ],\n    [\n        Status.NotFound,\n        \"Not Found\"\n    ],\n    [\n        Status.MethodNotAllowed,\n        \"Method Not Allowed\"\n    ],\n    [\n        Status.NotAcceptable,\n        \"Not Acceptable\"\n    ],\n    [\n        Status.ProxyAuthRequired,\n        \"Proxy Authentication Required\"\n    ],\n    [\n        Status.RequestTimeout,\n        \"Request Timeout\"\n    ],\n    [\n        Status.Conflict,\n        \"Conflict\"\n    ],\n    [\n        Status.Gone,\n        \"Gone\"\n    ],\n    [\n        Status.LengthRequired,\n        \"Length Required\"\n    ],\n    [\n        Status.PreconditionFailed,\n        \"Precondition Failed\"\n    ],\n    [\n        Status.RequestEntityTooLarge,\n        \"Request Entity Too Large\"\n    ],\n    [\n        Status.RequestURITooLong,\n        \"Request URI Too Long\"\n    ],\n    [\n        Status.UnsupportedMediaType,\n        \"Unsupported Media Type\"\n    ],\n    [\n        Status.RequestedRangeNotSatisfiable,\n        \"Requested Range Not Satisfiable\"\n    ],\n    [\n        Status.ExpectationFailed,\n        \"Expectation Failed\"\n    ],\n    [\n        Status.Teapot,\n        \"I'm a teapot\"\n    ],\n    [\n        Status.MisdirectedRequest,\n        \"Misdirected Request\"\n    ],\n    [\n        Status.UnprocessableEntity,\n        \"Unprocessable Entity\"\n    ],\n    [\n        Status.Locked,\n        \"Locked\"\n    ],\n    [\n        Status.FailedDependency,\n        \"Failed Dependency\"\n    ],\n    [\n        Status.TooEarly,\n        \"Too Early\"\n    ],\n    [\n        Status.UpgradeRequired,\n        \"Upgrade Required\"\n    ],\n    [\n        Status.PreconditionRequired,\n        \"Precondition Required\"\n    ],\n    [\n        Status.TooManyRequests,\n        \"Too Many Requests\"\n    ],\n    [\n        Status.RequestHeaderFieldsTooLarge,\n        \"Request Header Fields Too Large\"\n    ],\n    [\n        Status.UnavailableForLegalReasons,\n        \"Unavailable For Legal Reasons\"\n    ],\n    [\n        Status.InternalServerError,\n        \"Internal Server Error\"\n    ],\n    [\n        Status.NotImplemented,\n        \"Not Implemented\"\n    ],\n    [\n        Status.BadGateway,\n        \"Bad Gateway\"\n    ],\n    [\n        Status.ServiceUnavailable,\n        \"Service Unavailable\"\n    ],\n    [\n        Status.GatewayTimeout,\n        \"Gateway Timeout\"\n    ],\n    [\n        Status.HTTPVersionNotSupported,\n        \"HTTP Version Not Supported\"\n    ],\n    [\n        Status.VariantAlsoNegotiates,\n        \"Variant Also Negotiates\"\n    ],\n    [\n        Status.InsufficientStorage,\n        \"Insufficient Storage\"\n    ],\n    [\n        Status.LoopDetected,\n        \"Loop Detected\"\n    ],\n    [\n        Status.NotExtended,\n        \"Not Extended\"\n    ],\n    [\n        Status.NetworkAuthenticationRequired,\n        \"Network Authentication Required\"\n    ], \n]);\n","export function thenableReject(error) {\n    return {\n        then: (resolve, reject)=>reject(error)\n    };\n}\n","import { thenableReject } from 'https://raw.githubusercontent.com/vadzim/thenable-reject/master/src/thenable-reject.ts';\nexport async function* websocketData(websocket) {\n    for await (const { data  } of websocketEvents(websocket))yield data;\n}\nexport function websocketEvents(websocket, { emitOpen =false  } = {\n}) {\n    let done = false;\n    const values = [];\n    const resolvers = [];\n    const close = ()=>{\n        done = true;\n        while(resolvers.length > 0)resolvers.shift()({\n            value: undefined,\n            done: true\n        });\n    };\n    const push = (data)=>{\n        if (done) return;\n        if (resolvers.length > 0) {\n            resolvers.shift()(data);\n        } else {\n            values.push(data);\n        }\n    };\n    const pushError = (error)=>{\n        push(thenableReject(error));\n        close();\n    };\n    const pushEvent = (event)=>push({\n            value: event,\n            done: false\n        })\n    ;\n    const next = ()=>{\n        if (values.length > 0) return Promise.resolve(values.shift());\n        if (done) return Promise.resolve({\n            value: undefined,\n            done: true\n        });\n        return new Promise((resolve)=>resolvers.push(resolve)\n        );\n    };\n    const initSocket = ()=>{\n        websocket.onclose = close;\n        websocket.onerror = pushError;\n        websocket.onmessage = pushEvent;\n    };\n    if (websocket.readyState === WebSocket.CONNECTING) {\n        websocket.onopen = (event)=>{\n            if (emitOpen) pushEvent(event);\n            initSocket();\n        };\n    } else {\n        initSocket();\n    }\n    const iterator = {\n        [Symbol.asyncIterator]: ()=>iterator\n        ,\n        next,\n        throw: async (value)=>{\n            pushError(value);\n            if (websocket.readyState === WebSocket.OPEN) websocket.close();\n            return next();\n        },\n        return: async ()=>{\n            close();\n            if (websocket.readyState === WebSocket.OPEN) websocket.close();\n            return next();\n        }\n    };\n    return iterator;\n}\n","import { assert } from \"../_util/assert.ts\";\nconst DEFAULT_BUFFER_SIZE = 32 * 1024;\n/** copy N size at the most.\n *  If read size is lesser than N, then returns nread\n * */ export async function copyN(r, dest, size) {\n    let bytesRead = 0;\n    let buf = new Uint8Array(DEFAULT_BUFFER_SIZE);\n    while(bytesRead < size){\n        if (size - bytesRead < DEFAULT_BUFFER_SIZE) {\n            buf = new Uint8Array(size - bytesRead);\n        }\n        const result = await r.read(buf);\n        const nread = result ?? 0;\n        bytesRead += nread;\n        if (nread > 0) {\n            let n = 0;\n            while(n < nread){\n                n += await dest.write(buf.slice(n, nread));\n            }\n            assert(n === nread, \"could not write\");\n        }\n        if (result === null) {\n            break;\n        }\n    }\n    return bytesRead;\n}\n/** Read big endian 16bit short from BufReader */ export async function readShort(buf) {\n    const high = await buf.readByte();\n    if (high === null) return null;\n    const low = await buf.readByte();\n    if (low === null) throw new Deno.errors.UnexpectedEof();\n    return high << 8 | low;\n}\n/** Read big endian 32bit integer from BufReader */ export async function readInt(buf) {\n    const high = await readShort(buf);\n    if (high === null) return null;\n    const low = await readShort(buf);\n    if (low === null) throw new Deno.errors.UnexpectedEof();\n    return high << 16 | low;\n}\nconst MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\n/** Read big endian 64bit long from BufReader */ export async function readLong(buf) {\n    const high = await readInt(buf);\n    if (high === null) return null;\n    const low = await readInt(buf);\n    if (low === null) throw new Deno.errors.UnexpectedEof();\n    const big = BigInt(high) << 32n | BigInt(low);\n    // We probably should provide a similar API that returns BigInt values.\n    if (big > MAX_SAFE_INTEGER) {\n        throw new RangeError(\"Long value too big to be represented as a JavaScript number.\");\n    }\n    return Number(big);\n}\n/** Slice number into 64bit big endian byte array */ export function sliceLongToBytes(d, dest = new Array(8)) {\n    let big = BigInt(d);\n    for(let i = 0; i < 8; i++){\n        dest[7 - i] = Number(big & 255n);\n        big >>= 8n;\n    }\n    return dest;\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\nimport { decode, encode } from \"../encoding/utf8.ts\";\nimport { hasOwnProperty } from \"../_util/has_own_property.ts\";\nimport { BufReader, BufWriter } from \"../io/bufio.ts\";\nimport { readLong, readShort, sliceLongToBytes } from \"../io/ioutil.ts\";\nimport { Sha1 } from \"../hash/sha1.ts\";\nimport { writeResponse } from \"../http/_io.ts\";\nimport { TextProtoReader } from \"../textproto/mod.ts\";\nimport { deferred } from \"../async/deferred.ts\";\nimport { assert } from \"../_util/assert.ts\";\nimport { concat } from \"../bytes/mod.ts\";\nexport var OpCode;\n(function(OpCode) {\n    OpCode[OpCode[\"Continue\"] = 0] = \"Continue\";\n    OpCode[OpCode[\"TextFrame\"] = 1] = \"TextFrame\";\n    OpCode[OpCode[\"BinaryFrame\"] = 2] = \"BinaryFrame\";\n    OpCode[OpCode[\"Close\"] = 8] = \"Close\";\n    OpCode[OpCode[\"Ping\"] = 9] = \"Ping\";\n    OpCode[OpCode[\"Pong\"] = 10] = \"Pong\";\n})(OpCode || (OpCode = {\n}));\n/** Returns true if input value is a WebSocketCloseEvent, false otherwise. */ export function isWebSocketCloseEvent(a) {\n    return hasOwnProperty(a, \"code\");\n}\n/** Returns true if input value is a WebSocketPingEvent, false otherwise. */ export function isWebSocketPingEvent(a) {\n    return Array.isArray(a) && a[0] === \"ping\" && a[1] instanceof Uint8Array;\n}\n/** Returns true if input value is a WebSocketPongEvent, false otherwise. */ export function isWebSocketPongEvent(a) {\n    return Array.isArray(a) && a[0] === \"pong\" && a[1] instanceof Uint8Array;\n}\n/** Unmask masked websocket payload */ export function unmask(payload, mask) {\n    if (mask) {\n        for(let i = 0, len = payload.length; i < len; i++){\n            payload[i] ^= mask[i & 3];\n        }\n    }\n}\n/** Write WebSocket frame to inputted writer. */ export async function writeFrame(frame, writer) {\n    const payloadLength = frame.payload.byteLength;\n    let header;\n    const hasMask = frame.mask ? 128 : 0;\n    if (frame.mask && frame.mask.byteLength !== 4) {\n        throw new Error(\"invalid mask. mask must be 4 bytes: length=\" + frame.mask.byteLength);\n    }\n    if (payloadLength < 126) {\n        header = new Uint8Array([\n            128 | frame.opcode,\n            hasMask | payloadLength\n        ]);\n    } else if (payloadLength < 65535) {\n        header = new Uint8Array([\n            128 | frame.opcode,\n            hasMask | 126,\n            payloadLength >>> 8,\n            payloadLength & 255, \n        ]);\n    } else {\n        header = new Uint8Array([\n            128 | frame.opcode,\n            hasMask | 127,\n            ...sliceLongToBytes(payloadLength), \n        ]);\n    }\n    if (frame.mask) {\n        header = concat(header, frame.mask);\n    }\n    unmask(frame.payload, frame.mask);\n    header = concat(header, frame.payload);\n    const w = BufWriter.create(writer);\n    await w.write(header);\n    await w.flush();\n}\n/** Read websocket frame from given BufReader\n * @throws `Deno.errors.UnexpectedEof` When peer closed connection without close frame\n * @throws `Error` Frame is invalid\n */ export async function readFrame(buf) {\n    let b = await buf.readByte();\n    assert(b !== null);\n    let isLastFrame = false;\n    switch(b >>> 4){\n        case 8:\n            isLastFrame = true;\n            break;\n        case 0:\n            isLastFrame = false;\n            break;\n        default:\n            throw new Error(\"invalid signature\");\n    }\n    const opcode = b & 15;\n    // has_mask & payload\n    b = await buf.readByte();\n    assert(b !== null);\n    const hasMask = b >>> 7;\n    let payloadLength = b & 127;\n    if (payloadLength === 126) {\n        const l = await readShort(buf);\n        assert(l !== null);\n        payloadLength = l;\n    } else if (payloadLength === 127) {\n        const l = await readLong(buf);\n        assert(l !== null);\n        payloadLength = Number(l);\n    }\n    // mask\n    let mask;\n    if (hasMask) {\n        mask = new Uint8Array(4);\n        assert(await buf.readFull(mask) !== null);\n    }\n    // payload\n    const payload = new Uint8Array(payloadLength);\n    assert(await buf.readFull(payload) !== null);\n    return {\n        isLastFrame,\n        opcode,\n        mask,\n        payload\n    };\n}\nclass WebSocketImpl {\n    sendQueue = [];\n    constructor({ conn , bufReader , bufWriter , mask  }){\n        this.conn = conn;\n        this.mask = mask;\n        this.bufReader = bufReader || new BufReader(conn);\n        this.bufWriter = bufWriter || new BufWriter(conn);\n    }\n    async *[Symbol.asyncIterator]() {\n        let frames = [];\n        let payloadsLength = 0;\n        while(!this._isClosed){\n            let frame;\n            try {\n                frame = await readFrame(this.bufReader);\n            } catch (e) {\n                this.ensureSocketClosed();\n                break;\n            }\n            unmask(frame.payload, frame.mask);\n            switch(frame.opcode){\n                case OpCode.TextFrame:\n                case OpCode.BinaryFrame:\n                case OpCode.Continue:\n                    frames.push(frame);\n                    payloadsLength += frame.payload.length;\n                    if (frame.isLastFrame) {\n                        const concat = new Uint8Array(payloadsLength);\n                        let offs = 0;\n                        for (const frame of frames){\n                            concat.set(frame.payload, offs);\n                            offs += frame.payload.length;\n                        }\n                        if (frames[0].opcode === OpCode.TextFrame) {\n                            // text\n                            yield decode(concat);\n                        } else {\n                            // binary\n                            yield concat;\n                        }\n                        frames = [];\n                        payloadsLength = 0;\n                    }\n                    break;\n                case OpCode.Close:\n                    {\n                        // [0x12, 0x34] -> 0x1234\n                        const code = frame.payload[0] << 8 | frame.payload[1];\n                        const reason = decode(frame.payload.subarray(2, frame.payload.length));\n                        await this.close(code, reason);\n                        yield {\n                            code,\n                            reason\n                        };\n                        return;\n                    }\n                case OpCode.Ping:\n                    await this.enqueue({\n                        opcode: OpCode.Pong,\n                        payload: frame.payload,\n                        isLastFrame: true\n                    });\n                    yield [\n                        \"ping\",\n                        frame.payload\n                    ];\n                    break;\n                case OpCode.Pong:\n                    yield [\n                        \"pong\",\n                        frame.payload\n                    ];\n                    break;\n                default:\n            }\n        }\n    }\n    dequeue() {\n        const [entry] = this.sendQueue;\n        if (!entry) return;\n        if (this._isClosed) return;\n        const { d , frame  } = entry;\n        writeFrame(frame, this.bufWriter).then(()=>d.resolve()\n        ).catch((e)=>d.reject(e)\n        ).finally(()=>{\n            this.sendQueue.shift();\n            this.dequeue();\n        });\n    }\n    enqueue(frame) {\n        if (this._isClosed) {\n            throw new Deno.errors.ConnectionReset(\"Socket has already been closed\");\n        }\n        const d = deferred();\n        this.sendQueue.push({\n            d,\n            frame\n        });\n        if (this.sendQueue.length === 1) {\n            this.dequeue();\n        }\n        return d;\n    }\n    send(data) {\n        const opcode = typeof data === \"string\" ? OpCode.TextFrame : OpCode.BinaryFrame;\n        const payload = typeof data === \"string\" ? encode(data) : data;\n        const isLastFrame = true;\n        const frame = {\n            isLastFrame,\n            opcode,\n            payload,\n            mask: this.mask\n        };\n        return this.enqueue(frame);\n    }\n    ping(data = \"\") {\n        const payload = typeof data === \"string\" ? encode(data) : data;\n        const frame = {\n            isLastFrame: true,\n            opcode: OpCode.Ping,\n            mask: this.mask,\n            payload\n        };\n        return this.enqueue(frame);\n    }\n    _isClosed = false;\n    get isClosed() {\n        return this._isClosed;\n    }\n    async close(code = 1000, reason) {\n        try {\n            const header = [\n                code >>> 8,\n                code & 255\n            ];\n            let payload;\n            if (reason) {\n                const reasonBytes = encode(reason);\n                payload = new Uint8Array(2 + reasonBytes.byteLength);\n                payload.set(header);\n                payload.set(reasonBytes, 2);\n            } else {\n                payload = new Uint8Array(header);\n            }\n            await this.enqueue({\n                isLastFrame: true,\n                opcode: OpCode.Close,\n                mask: this.mask,\n                payload\n            });\n        } catch (e) {\n            throw e;\n        } finally{\n            this.ensureSocketClosed();\n        }\n    }\n    closeForce() {\n        this.ensureSocketClosed();\n    }\n    ensureSocketClosed() {\n        if (this.isClosed) return;\n        try {\n            this.conn.close();\n        } catch (e) {\n            console.error(e);\n        } finally{\n            this._isClosed = true;\n            const rest = this.sendQueue;\n            this.sendQueue = [];\n            rest.forEach((e)=>e.d.reject(new Deno.errors.ConnectionReset(\"Socket has already been closed\"))\n            );\n        }\n    }\n}\n/** Returns true if input headers are usable for WebSocket, otherwise false.  */ export function acceptable(req) {\n    const upgrade = req.headers.get(\"upgrade\");\n    if (!upgrade || upgrade.toLowerCase() !== \"websocket\") {\n        return false;\n    }\n    const secKey = req.headers.get(\"sec-websocket-key\");\n    return req.headers.has(\"sec-websocket-key\") && typeof secKey === \"string\" && secKey.length > 0;\n}\nconst kGUID = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n/** Create value of Sec-WebSocket-Accept header from inputted nonce. */ export function createSecAccept(nonce) {\n    const sha1 = new Sha1();\n    sha1.update(nonce + kGUID);\n    const bytes = sha1.digest();\n    return btoa(String.fromCharCode(...bytes));\n}\n/** Upgrade inputted TCP connection into WebSocket connection. */ export async function acceptWebSocket(req) {\n    const { conn , headers , bufReader , bufWriter  } = req;\n    if (acceptable(req)) {\n        const sock = new WebSocketImpl({\n            conn,\n            bufReader,\n            bufWriter\n        });\n        const secKey = headers.get(\"sec-websocket-key\");\n        if (typeof secKey !== \"string\") {\n            throw new Error(\"sec-websocket-key is not provided\");\n        }\n        const secAccept = createSecAccept(secKey);\n        const newHeaders = new Headers({\n            Upgrade: \"websocket\",\n            Connection: \"Upgrade\",\n            \"Sec-WebSocket-Accept\": secAccept\n        });\n        const secProtocol = headers.get(\"sec-websocket-protocol\");\n        if (typeof secProtocol === \"string\") {\n            newHeaders.set(\"Sec-WebSocket-Protocol\", secProtocol);\n        }\n        const secVersion = headers.get(\"sec-websocket-version\");\n        if (typeof secVersion === \"string\") {\n            newHeaders.set(\"Sec-WebSocket-Version\", secVersion);\n        }\n        await writeResponse(bufWriter, {\n            status: 101,\n            headers: newHeaders\n        });\n        return sock;\n    }\n    throw new Error(\"request is not acceptable\");\n}\nconst kSecChars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-.~_\";\n/** Returns base64 encoded 16 bytes string for Sec-WebSocket-Key header. */ export function createSecKey() {\n    let key = \"\";\n    for(let i = 0; i < 16; i++){\n        const j = Math.floor(Math.random() * kSecChars.length);\n        key += kSecChars[j];\n    }\n    return btoa(key);\n}\nexport async function handshake(url, headers, bufReader, bufWriter) {\n    const { hostname , pathname , search  } = url;\n    const key = createSecKey();\n    if (!headers.has(\"host\")) {\n        headers.set(\"host\", hostname);\n    }\n    headers.set(\"upgrade\", \"websocket\");\n    headers.set(\"connection\", \"upgrade\");\n    headers.set(\"sec-websocket-key\", key);\n    headers.set(\"sec-websocket-version\", \"13\");\n    let headerStr = `GET ${pathname}${search} HTTP/1.1\\r\\n`;\n    for (const [key, value] of headers){\n        headerStr += `${key}: ${value}\\r\\n`;\n    }\n    headerStr += \"\\r\\n\";\n    await bufWriter.write(encode(headerStr));\n    await bufWriter.flush();\n    const tpReader = new TextProtoReader(bufReader);\n    const statusLine = await tpReader.readLine();\n    if (statusLine === null) {\n        throw new Deno.errors.UnexpectedEof();\n    }\n    const m = statusLine.match(/^(?<version>\\S+) (?<statusCode>\\S+) /);\n    if (!m) {\n        throw new Error(\"ws: invalid status line: \" + statusLine);\n    }\n    assert(m.groups);\n    const { version , statusCode  } = m.groups;\n    if (version !== \"HTTP/1.1\" || statusCode !== \"101\") {\n        throw new Error(`ws: server didn't accept handshake: ` + `version=${version}, statusCode=${statusCode}`);\n    }\n    const responseHeaders = await tpReader.readMIMEHeader();\n    if (responseHeaders === null) {\n        throw new Deno.errors.UnexpectedEof();\n    }\n    const expectedSecAccept = createSecAccept(key);\n    const secAccept = responseHeaders.get(\"sec-websocket-accept\");\n    if (secAccept !== expectedSecAccept) {\n        throw new Error(`ws: unexpected sec-websocket-accept header: ` + `expected=${expectedSecAccept}, actual=${secAccept}`);\n    }\n}\nexport function createWebSocket(params) {\n    return new WebSocketImpl(params);\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n/**\n * Converts the byte array to a UUID string\n * @param bytes Used to convert Byte to Hex\n */ export function bytesToUuid(bytes) {\n    const bits = [\n        ...bytes\n    ].map((bit)=>{\n        const s = bit.toString(16);\n        return bit < 16 ? \"0\" + s : s;\n    });\n    return [\n        ...bits.slice(0, 4),\n        \"-\",\n        ...bits.slice(4, 6),\n        \"-\",\n        ...bits.slice(6, 8),\n        \"-\",\n        ...bits.slice(8, 10),\n        \"-\",\n        ...bits.slice(10, 16), \n    ].join(\"\");\n}\n/**\n * Converts a string to a byte array by converting the hex value to a number\n * @param uuid Value that gets converted\n */ export function uuidToBytes(uuid) {\n    const bytes = [];\n    uuid.replace(/[a-fA-F0-9]{2}/g, (hex)=>{\n        bytes.push(parseInt(hex, 16));\n        return \"\";\n    });\n    return bytes;\n}\n/**\n * Converts a string to a byte array using the char code\n * @param str Value that gets converted\n */ export function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Array(str.length);\n    for(let i = 0; i < str.length; i++){\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\n/**\n * Creates a buffer for creating a SHA-1 hash\n * @param content Buffer for SHA-1 hash\n */ export function createBuffer(content) {\n    const arrayBuffer = new ArrayBuffer(content.length);\n    const uint8Array = new Uint8Array(arrayBuffer);\n    for(let i = 0; i < content.length; i++){\n        uint8Array[i] = content[i];\n    }\n    return arrayBuffer;\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\nimport { bytesToUuid } from \"./_common.ts\";\nconst UUID_RE = new RegExp(\"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\", \"i\");\n/**\n * Validates the UUID v4\n * @param id UUID value\n */ export function validate(id) {\n    return UUID_RE.test(id);\n}\n/** Generates a RFC4122 v4 UUID (pseudo-randomly-based) */ export function generate() {\n    const rnds = crypto.getRandomValues(new Uint8Array(16));\n    rnds[6] = rnds[6] & 15 | 64; // Version 4\n    rnds[8] = rnds[8] & 63 | 128; // Variant 10\n    return bytesToUuid(rnds);\n}\n","// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors\n// on npm.\n//\n// ```\n// import { bgBlue, red, bold } from \"https://deno.land/std/fmt/colors.ts\";\n// console.log(bgBlue(red(bold(\"Hello world!\"))));\n// ```\n//\n// This module supports `NO_COLOR` environmental variable disabling any coloring\n// if `NO_COLOR` is set.\n//\n// This module is browser compatible.\nconst noColor = globalThis.Deno?.noColor ?? true;\nlet enabled = !noColor;\n/**\n * Set changing text color to enabled or disabled\n * @param value\n */ export function setColorEnabled(value) {\n    if (noColor) {\n        return;\n    }\n    enabled = value;\n}\n/** Get whether text color change is enabled or disabled. */ export function getColorEnabled() {\n    return enabled;\n}\n/**\n * Builds color code\n * @param open\n * @param close\n */ function code(open, close) {\n    return {\n        open: `\\x1b[${open.join(\";\")}m`,\n        close: `\\x1b[${close}m`,\n        regexp: new RegExp(`\\\\x1b\\\\[${close}m`, \"g\")\n    };\n}\n/**\n * Applies color and background based on color code and its associated text\n * @param str text to apply color settings to\n * @param code color code to apply\n */ function run(str, code) {\n    return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;\n}\n/**\n * Reset the text modified\n * @param str text to reset\n */ export function reset(str) {\n    return run(str, code([\n        0\n    ], 0));\n}\n/**\n * Make the text bold.\n * @param str text to make bold\n */ export function bold(str) {\n    return run(str, code([\n        1\n    ], 22));\n}\n/**\n * The text emits only a small amount of light.\n * @param str text to dim\n */ export function dim(str) {\n    return run(str, code([\n        2\n    ], 22));\n}\n/**\n * Make the text italic.\n * @param str text to make italic\n */ export function italic(str) {\n    return run(str, code([\n        3\n    ], 23));\n}\n/**\n * Make the text underline.\n * @param str text to underline\n */ export function underline(str) {\n    return run(str, code([\n        4\n    ], 24));\n}\n/**\n * Invert background color and text color.\n * @param str text to invert its color\n */ export function inverse(str) {\n    return run(str, code([\n        7\n    ], 27));\n}\n/**\n * Make the text hidden.\n * @param str text to hide\n */ export function hidden(str) {\n    return run(str, code([\n        8\n    ], 28));\n}\n/**\n * Put horizontal line through the center of the text.\n * @param str text to strike through\n */ export function strikethrough(str) {\n    return run(str, code([\n        9\n    ], 29));\n}\n/**\n * Set text color to black.\n * @param str text to make black\n */ export function black(str) {\n    return run(str, code([\n        30\n    ], 39));\n}\n/**\n * Set text color to red.\n * @param str text to make red\n */ export function red(str) {\n    return run(str, code([\n        31\n    ], 39));\n}\n/**\n * Set text color to green.\n * @param str text to make green\n */ export function green(str) {\n    return run(str, code([\n        32\n    ], 39));\n}\n/**\n * Set text color to yellow.\n * @param str text to make yellow\n */ export function yellow(str) {\n    return run(str, code([\n        33\n    ], 39));\n}\n/**\n * Set text color to blue.\n * @param str text to make blue\n */ export function blue(str) {\n    return run(str, code([\n        34\n    ], 39));\n}\n/**\n * Set text color to magenta.\n * @param str text to make magenta\n */ export function magenta(str) {\n    return run(str, code([\n        35\n    ], 39));\n}\n/**\n * Set text color to cyan.\n * @param str text to make cyan\n */ export function cyan(str) {\n    return run(str, code([\n        36\n    ], 39));\n}\n/**\n * Set text color to white.\n * @param str text to make white\n */ export function white(str) {\n    return run(str, code([\n        37\n    ], 39));\n}\n/**\n * Set text color to gray.\n * @param str text to make gray\n */ export function gray(str) {\n    return brightBlack(str);\n}\n/**\n * Set text color to bright black.\n * @param str text to make bright-black\n */ export function brightBlack(str) {\n    return run(str, code([\n        90\n    ], 39));\n}\n/**\n * Set text color to bright red.\n * @param str text to make bright-red\n */ export function brightRed(str) {\n    return run(str, code([\n        91\n    ], 39));\n}\n/**\n * Set text color to bright green.\n * @param str text to make bright-green\n */ export function brightGreen(str) {\n    return run(str, code([\n        92\n    ], 39));\n}\n/**\n * Set text color to bright yellow.\n * @param str text to make bright-yellow\n */ export function brightYellow(str) {\n    return run(str, code([\n        93\n    ], 39));\n}\n/**\n * Set text color to bright blue.\n * @param str text to make bright-blue\n */ export function brightBlue(str) {\n    return run(str, code([\n        94\n    ], 39));\n}\n/**\n * Set text color to bright magenta.\n * @param str text to make bright-magenta\n */ export function brightMagenta(str) {\n    return run(str, code([\n        95\n    ], 39));\n}\n/**\n * Set text color to bright cyan.\n * @param str text to make bright-cyan\n */ export function brightCyan(str) {\n    return run(str, code([\n        96\n    ], 39));\n}\n/**\n * Set text color to bright white.\n * @param str text to make bright-white\n */ export function brightWhite(str) {\n    return run(str, code([\n        97\n    ], 39));\n}\n/**\n * Set background color to black.\n * @param str text to make its background black\n */ export function bgBlack(str) {\n    return run(str, code([\n        40\n    ], 49));\n}\n/**\n * Set background color to red.\n * @param str text to make its background red\n */ export function bgRed(str) {\n    return run(str, code([\n        41\n    ], 49));\n}\n/**\n * Set background color to green.\n * @param str text to make its background green\n */ export function bgGreen(str) {\n    return run(str, code([\n        42\n    ], 49));\n}\n/**\n * Set background color to yellow.\n * @param str text to make its background yellow\n */ export function bgYellow(str) {\n    return run(str, code([\n        43\n    ], 49));\n}\n/**\n * Set background color to blue.\n * @param str text to make its background blue\n */ export function bgBlue(str) {\n    return run(str, code([\n        44\n    ], 49));\n}\n/**\n *  Set background color to magenta.\n * @param str text to make its background magenta\n */ export function bgMagenta(str) {\n    return run(str, code([\n        45\n    ], 49));\n}\n/**\n * Set background color to cyan.\n * @param str text to make its background cyan\n */ export function bgCyan(str) {\n    return run(str, code([\n        46\n    ], 49));\n}\n/**\n * Set background color to white.\n * @param str text to make its background white\n */ export function bgWhite(str) {\n    return run(str, code([\n        47\n    ], 49));\n}\n/**\n * Set background color to bright black.\n * @param str text to make its background bright-black\n */ export function bgBrightBlack(str) {\n    return run(str, code([\n        100\n    ], 49));\n}\n/**\n * Set background color to bright red.\n * @param str text to make its background bright-red\n */ export function bgBrightRed(str) {\n    return run(str, code([\n        101\n    ], 49));\n}\n/**\n * Set background color to bright green.\n * @param str text to make its background bright-green\n */ export function bgBrightGreen(str) {\n    return run(str, code([\n        102\n    ], 49));\n}\n/**\n * Set background color to bright yellow.\n * @param str text to make its background bright-yellow\n */ export function bgBrightYellow(str) {\n    return run(str, code([\n        103\n    ], 49));\n}\n/**\n * Set background color to bright blue.\n * @param str text to make its background bright-blue\n */ export function bgBrightBlue(str) {\n    return run(str, code([\n        104\n    ], 49));\n}\n/**\n * Set background color to bright magenta.\n * @param str text to make its background bright-magenta\n */ export function bgBrightMagenta(str) {\n    return run(str, code([\n        105\n    ], 49));\n}\n/**\n * Set background color to bright cyan.\n * @param str text to make its background bright-cyan\n */ export function bgBrightCyan(str) {\n    return run(str, code([\n        106\n    ], 49));\n}\n/**\n * Set background color to bright white.\n * @param str text to make its background bright-white\n */ export function bgBrightWhite(str) {\n    return run(str, code([\n        107\n    ], 49));\n}\n/* Special Color Sequences */ /**\n * Clam and truncate color codes\n * @param n\n * @param max number to truncate to\n * @param min number to truncate from\n */ function clampAndTruncate(n, max = 255, min = 0) {\n    return Math.trunc(Math.max(Math.min(n, max), min));\n}\n/**\n * Set text color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit colors to\n * @param color code\n */ export function rgb8(str, color) {\n    return run(str, code([\n        38,\n        5,\n        clampAndTruncate(color)\n    ], 39));\n}\n/**\n * Set background color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit background colors to\n * @param color code\n */ export function bgRgb8(str, color) {\n    return run(str, code([\n        48,\n        5,\n        clampAndTruncate(color)\n    ], 49));\n}\n/**\n * Set text color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n *      rgb24(\"foo\", 0xff00ff);\n *      rgb24(\"foo\", {r: 255, g: 0, b: 255});\n * @param str text color to apply 24bit rgb to\n * @param color code\n */ export function rgb24(str, color) {\n    if (typeof color === \"number\") {\n        return run(str, code([\n            38,\n            2,\n            color >> 16 & 255,\n            color >> 8 & 255,\n            color & 255\n        ], 39));\n    }\n    return run(str, code([\n        38,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b), \n    ], 39));\n}\n/**\n * Set background color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n *      bgRgb24(\"foo\", 0xff00ff);\n *      bgRgb24(\"foo\", {r: 255, g: 0, b: 255});\n * @param str text color to apply 24bit rgb to\n * @param color code\n */ export function bgRgb24(str, color) {\n    if (typeof color === \"number\") {\n        return run(str, code([\n            48,\n            2,\n            color >> 16 & 255,\n            color >> 8 & 255,\n            color & 255\n        ], 49));\n    }\n    return run(str, code([\n        48,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b), \n    ], 49));\n}\n// https://github.com/chalk/ansi-regex/blob/2b56fb0c7a07108e5b54241e8faec160d393aedb/index.js\nconst ANSI_PATTERN = new RegExp([\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\", \n].join(\"|\"), \"g\");\n/**\n * Remove ANSI escape codes from the string.\n * @param string to remove ANSI escape codes from\n */ export function stripColor(string) {\n    return string.replace(ANSI_PATTERN, \"\");\n}\n","export var DiffType;\n(function(DiffType) {\n    DiffType[\"removed\"] = \"removed\";\n    DiffType[\"common\"] = \"common\";\n    DiffType[\"added\"] = \"added\";\n})(DiffType || (DiffType = {\n}));\nconst REMOVED = 1;\nconst COMMON = 2;\nconst ADDED = 3;\nfunction createCommon(A, B, reverse) {\n    const common = [];\n    if (A.length === 0 || B.length === 0) return [];\n    for(let i = 0; i < Math.min(A.length, B.length); i += 1){\n        if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {\n            common.push(A[reverse ? A.length - i - 1 : i]);\n        } else {\n            return common;\n        }\n    }\n    return common;\n}\n/**\n * Renders the differences between the actual and expected values\n * @param A Actual value\n * @param B Expected value\n */ export function diff(A, B) {\n    const prefixCommon = createCommon(A, B);\n    const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();\n    A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);\n    B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);\n    const swapped = B.length > A.length;\n    [A, B] = swapped ? [\n        B,\n        A\n    ] : [\n        A,\n        B\n    ];\n    const M = A.length;\n    const N = B.length;\n    if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];\n    if (!N) {\n        return [\n            ...prefixCommon.map((c)=>({\n                    type: DiffType.common,\n                    value: c\n                })\n            ),\n            ...A.map((a)=>({\n                    type: swapped ? DiffType.added : DiffType.removed,\n                    value: a\n                })\n            ),\n            ...suffixCommon.map((c)=>({\n                    type: DiffType.common,\n                    value: c\n                })\n            ), \n        ];\n    }\n    const offset = N;\n    const delta = M - N;\n    const size = M + N + 1;\n    const fp = new Array(size).fill({\n        y: -1\n    });\n    /**\n   * INFO:\n   * This buffer is used to save memory and improve performance.\n   * The first half is used to save route and last half is used to save diff\n   * type.\n   * This is because, when I kept new uint8array area to save type,performance\n   * worsened.\n   */ const routes = new Uint32Array((M * N + size + 1) * 2);\n    const diffTypesPtrOffset = routes.length / 2;\n    let ptr = 0;\n    let p = -1;\n    function backTrace(A, B, current, swapped) {\n        const M = A.length;\n        const N = B.length;\n        const result = [];\n        let a = M - 1;\n        let b = N - 1;\n        let j = routes[current.id];\n        let type = routes[current.id + diffTypesPtrOffset];\n        while(true){\n            if (!j && !type) break;\n            const prev = j;\n            if (type === REMOVED) {\n                result.unshift({\n                    type: swapped ? DiffType.removed : DiffType.added,\n                    value: B[b]\n                });\n                b -= 1;\n            } else if (type === ADDED) {\n                result.unshift({\n                    type: swapped ? DiffType.added : DiffType.removed,\n                    value: A[a]\n                });\n                a -= 1;\n            } else {\n                result.unshift({\n                    type: DiffType.common,\n                    value: A[a]\n                });\n                a -= 1;\n                b -= 1;\n            }\n            j = routes[prev];\n            type = routes[prev + diffTypesPtrOffset];\n        }\n        return result;\n    }\n    function createFP(slide, down, k, M) {\n        if (slide && slide.y === -1 && down && down.y === -1) {\n            return {\n                y: 0,\n                id: 0\n            };\n        }\n        if (down && down.y === -1 || k === M || (slide && slide.y) > (down && down.y) + 1) {\n            const prev = slide.id;\n            ptr++;\n            routes[ptr] = prev;\n            routes[ptr + diffTypesPtrOffset] = ADDED;\n            return {\n                y: slide.y,\n                id: ptr\n            };\n        } else {\n            const prev = down.id;\n            ptr++;\n            routes[ptr] = prev;\n            routes[ptr + diffTypesPtrOffset] = REMOVED;\n            return {\n                y: down.y + 1,\n                id: ptr\n            };\n        }\n    }\n    function snake(k, slide, down, _offset, A, B) {\n        const M = A.length;\n        const N = B.length;\n        if (k < -N || M < k) return {\n            y: -1,\n            id: -1\n        };\n        const fp = createFP(slide, down, k, M);\n        while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){\n            const prev = fp.id;\n            ptr++;\n            fp.id = ptr;\n            fp.y += 1;\n            routes[ptr] = prev;\n            routes[ptr + diffTypesPtrOffset] = COMMON;\n        }\n        return fp;\n    }\n    while(fp[delta + offset].y < N){\n        p = p + 1;\n        for(let k = -p; k < delta; ++k){\n            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);\n        }\n        for(let k = delta + p; k > delta; --k){\n            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);\n        }\n        fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);\n    }\n    return [\n        ...prefixCommon.map((c)=>({\n                type: DiffType.common,\n                value: c\n            })\n        ),\n        ...backTrace(A, B, fp[delta + offset], swapped),\n        ...suffixCommon.map((c)=>({\n                type: DiffType.common,\n                value: c\n            })\n        ), \n    ];\n}\n","// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\nexport class DenoStdInternalError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"DenoStdInternalError\";\n    }\n}\n/** Make an assertion, if not `true`, then throw. */ export function assert(expr, msg = \"\") {\n    if (!expr) {\n        throw new DenoStdInternalError(msg);\n    }\n}\n","// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\nimport { deferred } from \"../async/mod.ts\";\nimport { assert, assertStringIncludes, fail } from \"../testing/asserts.ts\";\nimport { readAll } from \"../io/util.ts\";\nexport function notImplemented(msg) {\n    const message = msg ? `Not implemented: ${msg}` : \"Not implemented\";\n    throw new Error(message);\n}\nexport const _TextDecoder = TextDecoder;\nexport const _TextEncoder = TextEncoder;\nexport function intoCallbackAPI(// deno-lint-ignore no-explicit-any\nfunc, cb, // deno-lint-ignore no-explicit-any\n...args) {\n    func(...args).then((value)=>cb && cb(null, value)\n    , (err)=>cb && cb(err)\n    );\n}\nexport function intoCallbackAPIWithIntercept(// deno-lint-ignore no-explicit-any\nfunc, interceptor, cb, // deno-lint-ignore no-explicit-any\n...args) {\n    func(...args).then((value)=>cb && cb(null, interceptor(value))\n    , (err)=>cb && cb(err)\n    );\n}\nexport function spliceOne(list, index) {\n    for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n    list.pop();\n}\n// Taken from: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L125\n// Return undefined if there is no match.\n// Move the \"slow cases\" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nexport function normalizeEncoding(enc) {\n    if (enc == null || enc === \"utf8\" || enc === \"utf-8\") return \"utf8\";\n    return slowCases(enc);\n}\n// https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L130\nfunction slowCases(enc) {\n    switch(enc.length){\n        case 4:\n            if (enc === \"UTF8\") return \"utf8\";\n            if (enc === \"ucs2\" || enc === \"UCS2\") return \"utf16le\";\n            enc = `${enc}`.toLowerCase();\n            if (enc === \"utf8\") return \"utf8\";\n            if (enc === \"ucs2\") return \"utf16le\";\n            break;\n        case 3:\n            if (enc === \"hex\" || enc === \"HEX\" || `${enc}`.toLowerCase() === \"hex\") {\n                return \"hex\";\n            }\n            break;\n        case 5:\n            if (enc === \"ascii\") return \"ascii\";\n            if (enc === \"ucs-2\") return \"utf16le\";\n            if (enc === \"UTF-8\") return \"utf8\";\n            if (enc === \"ASCII\") return \"ascii\";\n            if (enc === \"UCS-2\") return \"utf16le\";\n            enc = `${enc}`.toLowerCase();\n            if (enc === \"utf-8\") return \"utf8\";\n            if (enc === \"ascii\") return \"ascii\";\n            if (enc === \"ucs-2\") return \"utf16le\";\n            break;\n        case 6:\n            if (enc === \"base64\") return \"base64\";\n            if (enc === \"latin1\" || enc === \"binary\") return \"latin1\";\n            if (enc === \"BASE64\") return \"base64\";\n            if (enc === \"LATIN1\" || enc === \"BINARY\") return \"latin1\";\n            enc = `${enc}`.toLowerCase();\n            if (enc === \"base64\") return \"base64\";\n            if (enc === \"latin1\" || enc === \"binary\") return \"latin1\";\n            break;\n        case 7:\n            if (enc === \"utf16le\" || enc === \"UTF16LE\" || `${enc}`.toLowerCase() === \"utf16le\") {\n                return \"utf16le\";\n            }\n            break;\n        case 8:\n            if (enc === \"utf-16le\" || enc === \"UTF-16LE\" || `${enc}`.toLowerCase() === \"utf-16le\") {\n                return \"utf16le\";\n            }\n            break;\n        default:\n            if (enc === \"\") return \"utf8\";\n    }\n}\nexport function validateIntegerRange(value, name, min = -2147483648, max = 2147483647) {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (!Number.isInteger(value)) {\n        throw new Error(`${name} must be 'an integer' but was ${value}`);\n    }\n    if (value < min || value > max) {\n        throw new Error(`${name} must be >= ${min} && <= ${max}. Value was ${value}`);\n    }\n}\nexport function once(callback) {\n    let called = false;\n    return function(...args) {\n        if (called) return;\n        called = true;\n        callback.apply(this, args);\n    };\n}\n/**\n * @param {number} [expectedExecutions = 1]\n * @param {number} [timeout = 1000] Milliseconds to wait before the promise is forcefully exited\n*/ export function mustCall(fn = ()=>{\n}, expectedExecutions = 1, timeout = 1000) {\n    if (expectedExecutions < 1) {\n        throw new Error(\"Expected executions can't be lower than 1\");\n    }\n    let timesExecuted = 0;\n    const completed = deferred();\n    const abort = setTimeout(()=>completed.reject()\n    , timeout);\n    function callback(...args) {\n        timesExecuted++;\n        if (timesExecuted === expectedExecutions) {\n            completed.resolve();\n        }\n        fn.apply(this, args);\n    }\n    const result = completed.then(()=>clearTimeout(abort)\n    ).catch(()=>fail(`Async operation not completed: Expected ${expectedExecutions}, executed ${timesExecuted}`)\n    );\n    return [\n        result,\n        callback, \n    ];\n}\n/** Asserts that an error thrown in a callback will not be wrongly caught. */ export async function assertCallbackErrorUncaught({ prelude , invocation , cleanup  }) {\n    // Since the error has to be uncaught, and that will kill the Deno process,\n    // the only way to test this is to spawn a subprocess.\n    const p = Deno.run({\n        cmd: [\n            Deno.execPath(),\n            \"eval\",\n            \"--no-check\",\n            \"--unstable\",\n            `${prelude ?? \"\"}\\n\\n      ${invocation}(err) => {\\n        // If the bug is present and the callback is called again with an error,\\n        // don't throw another error, so if the subprocess fails we know it had the correct behaviour.\\n        if (!err) throw new Error(\"success\");\\n      });`, \n        ],\n        stderr: \"piped\"\n    });\n    const status = await p.status();\n    const stderr = new TextDecoder().decode(await readAll(p.stderr));\n    p.close();\n    p.stderr.close();\n    await cleanup?.();\n    assert(!status.success);\n    assertStringIncludes(stderr, \"Error: success\");\n}\n","// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n// Copyright (c) 2019 Denolibs authors. All rights reserved. MIT license.\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nimport { validateIntegerRange } from \"./_utils.ts\";\nimport { assert } from \"../_util/assert.ts\";\n// deno-lint-ignore no-explicit-any\nfunction createIterResult(value, done) {\n    return {\n        value,\n        done\n    };\n}\nexport let defaultMaxListeners = 10;\n/**\n * See also https://nodejs.org/api/events.html\n */ export class EventEmitter {\n    static captureRejectionSymbol = Symbol.for(\"nodejs.rejection\");\n    static errorMonitor = Symbol(\"events.errorMonitor\");\n    static get defaultMaxListeners() {\n        return defaultMaxListeners;\n    }\n    static set defaultMaxListeners(value) {\n        defaultMaxListeners = value;\n    }\n    constructor(){\n        this._events = new Map();\n    }\n    _addListener(eventName, listener, prepend) {\n        this.emit(\"newListener\", eventName, listener);\n        if (this._events.has(eventName)) {\n            const listeners = this._events.get(eventName);\n            if (prepend) {\n                listeners.unshift(listener);\n            } else {\n                listeners.push(listener);\n            }\n        } else {\n            this._events.set(eventName, [\n                listener\n            ]);\n        }\n        const max = this.getMaxListeners();\n        if (max > 0 && this.listenerCount(eventName) > max) {\n            const warning = new Error(`Possible EventEmitter memory leak detected.\\n         ${this.listenerCount(eventName)} ${eventName.toString()} listeners.\\n         Use emitter.setMaxListeners() to increase limit`);\n            warning.name = \"MaxListenersExceededWarning\";\n            console.warn(warning);\n        }\n        return this;\n    }\n    /** Alias for emitter.on(eventName, listener). */ addListener(eventName, listener) {\n        return this._addListener(eventName, listener, false);\n    }\n    /**\n   * Synchronously calls each of the listeners registered for the event named\n   * eventName, in the order they were registered, passing the supplied\n   * arguments to each.\n   * @return true if the event had listeners, false otherwise\n   */ // deno-lint-ignore no-explicit-any\n    emit(eventName, ...args) {\n        if (this._events.has(eventName)) {\n            if (eventName === \"error\" && this._events.get(EventEmitter.errorMonitor)) {\n                this.emit(EventEmitter.errorMonitor, ...args);\n            }\n            const listeners = this._events.get(eventName).slice(); // We copy with slice() so array is not mutated during emit\n            for (const listener of listeners){\n                try {\n                    listener.apply(this, args);\n                } catch (err) {\n                    this.emit(\"error\", err);\n                }\n            }\n            return true;\n        } else if (eventName === \"error\") {\n            if (this._events.get(EventEmitter.errorMonitor)) {\n                this.emit(EventEmitter.errorMonitor, ...args);\n            }\n            const errMsg = args.length > 0 ? args[0] : Error(\"Unhandled error.\");\n            throw errMsg;\n        }\n        return false;\n    }\n    /**\n   * Returns an array listing the events for which the emitter has\n   * registered listeners.\n   */ eventNames() {\n        return Array.from(this._events.keys());\n    }\n    /**\n   * Returns the current max listener value for the EventEmitter which is\n   * either set by emitter.setMaxListeners(n) or defaults to\n   * EventEmitter.defaultMaxListeners.\n   */ getMaxListeners() {\n        return this.maxListeners || EventEmitter.defaultMaxListeners;\n    }\n    /**\n   * Returns the number of listeners listening to the event named\n   * eventName.\n   */ listenerCount(eventName) {\n        if (this._events.has(eventName)) {\n            return this._events.get(eventName).length;\n        } else {\n            return 0;\n        }\n    }\n    static listenerCount(emitter, eventName) {\n        return emitter.listenerCount(eventName);\n    }\n    _listeners(target, eventName, unwrap) {\n        if (!target._events.has(eventName)) {\n            return [];\n        }\n        const eventListeners = target._events.get(eventName);\n        return unwrap ? this.unwrapListeners(eventListeners) : eventListeners.slice(0);\n    }\n    unwrapListeners(arr) {\n        const unwrappedListeners = new Array(arr.length);\n        for(let i = 0; i < arr.length; i++){\n            // deno-lint-ignore no-explicit-any\n            unwrappedListeners[i] = arr[i][\"listener\"] || arr[i];\n        }\n        return unwrappedListeners;\n    }\n    /** Returns a copy of the array of listeners for the event named eventName.*/ listeners(eventName) {\n        return this._listeners(this, eventName, true);\n    }\n    /**\n   * Returns a copy of the array of listeners for the event named eventName,\n   * including any wrappers (such as those created by .once()).\n   */ rawListeners(eventName) {\n        return this._listeners(this, eventName, false);\n    }\n    /** Alias for emitter.removeListener(). */ off(eventName, listener) {\n        return this.removeListener(eventName, listener);\n    }\n    /**\n   * Adds the listener function to the end of the listeners array for the event\n   *  named eventName. No checks are made to see if the listener has already\n   * been added. Multiple calls passing the same combination of eventName and\n   * listener will result in the listener being added, and called, multiple\n   * times.\n   */ on(eventName, listener) {\n        return this._addListener(eventName, listener, false);\n    }\n    /**\n   * Adds a one-time listener function for the event named eventName. The next\n   * time eventName is triggered, this listener is removed and then invoked.\n   */ once(eventName, listener) {\n        const wrapped = this.onceWrap(eventName, listener);\n        this.on(eventName, wrapped);\n        return this;\n    }\n    // Wrapped function that calls EventEmitter.removeListener(eventName, self) on execution.\n    onceWrap(eventName, listener) {\n        const wrapper = function(// deno-lint-ignore no-explicit-any\n        ...args) {\n            this.context.removeListener(this.eventName, this.rawListener);\n            this.listener.apply(this.context, args);\n        };\n        const wrapperContext = {\n            eventName: eventName,\n            listener: listener,\n            rawListener: wrapper,\n            context: this\n        };\n        const wrapped = wrapper.bind(wrapperContext);\n        wrapperContext.rawListener = wrapped;\n        wrapped.listener = listener;\n        return wrapped;\n    }\n    /**\n   * Adds the listener function to the beginning of the listeners array for the\n   *  event named eventName. No checks are made to see if the listener has\n   * already been added. Multiple calls passing the same combination of\n   * eventName and listener will result in the listener being added, and\n   * called, multiple times.\n   */ prependListener(eventName, listener) {\n        return this._addListener(eventName, listener, true);\n    }\n    /**\n   * Adds a one-time listener function for the event named eventName to the\n   * beginning of the listeners array. The next time eventName is triggered,\n   * this listener is removed, and then invoked.\n   */ prependOnceListener(eventName, listener) {\n        const wrapped = this.onceWrap(eventName, listener);\n        this.prependListener(eventName, wrapped);\n        return this;\n    }\n    /** Removes all listeners, or those of the specified eventName. */ removeAllListeners(eventName) {\n        if (this._events === undefined) {\n            return this;\n        }\n        if (eventName) {\n            if (this._events.has(eventName)) {\n                const listeners = this._events.get(eventName).slice(); // Create a copy; We use it AFTER it's deleted.\n                this._events.delete(eventName);\n                for (const listener of listeners){\n                    this.emit(\"removeListener\", eventName, listener);\n                }\n            }\n        } else {\n            const eventList = this.eventNames();\n            eventList.map((value)=>{\n                this.removeAllListeners(value);\n            });\n        }\n        return this;\n    }\n    /**\n   * Removes the specified listener from the listener array for the event\n   * named eventName.\n   */ removeListener(eventName, listener) {\n        if (this._events.has(eventName)) {\n            const arr = this._events.get(eventName);\n            assert(arr);\n            let listenerIndex = -1;\n            for(let i = arr.length - 1; i >= 0; i--){\n                // arr[i][\"listener\"] is the reference to the listener inside a bound 'once' wrapper\n                if (arr[i] == listener || arr[i] && arr[i][\"listener\"] == listener) {\n                    listenerIndex = i;\n                    break;\n                }\n            }\n            if (listenerIndex >= 0) {\n                arr.splice(listenerIndex, 1);\n                this.emit(\"removeListener\", eventName, listener);\n                if (arr.length === 0) {\n                    this._events.delete(eventName);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n   * By default EventEmitters will print a warning if more than 10 listeners\n   * are added for a particular event. This is a useful default that helps\n   * finding memory leaks. Obviously, not all events should be limited to just\n   * 10 listeners. The emitter.setMaxListeners() method allows the limit to be\n   * modified for this specific EventEmitter instance. The value can be set to\n   * Infinity (or 0) to indicate an unlimited number of listeners.\n   */ setMaxListeners(n) {\n        if (n !== Infinity) {\n            if (n === 0) {\n                n = Infinity;\n            } else {\n                validateIntegerRange(n, \"maxListeners\", 0);\n            }\n        }\n        this.maxListeners = n;\n        return this;\n    }\n    /**\n   * Creates a Promise that is fulfilled when the EventEmitter emits the given\n   * event or that is rejected when the EventEmitter emits 'error'. The Promise\n   * will resolve with an array of all the arguments emitted to the given event.\n   */ static once(emitter, name) {\n        return new Promise((resolve, reject)=>{\n            if (emitter instanceof EventTarget) {\n                // EventTarget does not have `error` event semantics like Node\n                // EventEmitters, we do not listen to `error` events here.\n                emitter.addEventListener(name, (...args)=>{\n                    resolve(args);\n                }, {\n                    once: true,\n                    passive: false,\n                    capture: false\n                });\n                return;\n            } else if (emitter instanceof EventEmitter) {\n                // deno-lint-ignore no-explicit-any\n                const eventListener = (...args)=>{\n                    if (errorListener !== undefined) {\n                        emitter.removeListener(\"error\", errorListener);\n                    }\n                    resolve(args);\n                };\n                let errorListener;\n                // Adding an error listener is not optional because\n                // if an error is thrown on an event emitter we cannot\n                // guarantee that the actual event we are waiting will\n                // be fired. The result could be a silent way to create\n                // memory or file descriptor leaks, which is something\n                // we should avoid.\n                if (name !== \"error\") {\n                    // deno-lint-ignore no-explicit-any\n                    errorListener = (err)=>{\n                        emitter.removeListener(name, eventListener);\n                        reject(err);\n                    };\n                    emitter.once(\"error\", errorListener);\n                }\n                emitter.once(name, eventListener);\n                return;\n            }\n        });\n    }\n    /**\n   * Returns an AsyncIterator that iterates eventName events. It will throw if\n   * the EventEmitter emits 'error'. It removes all listeners when exiting the\n   * loop. The value returned by each iteration is an array composed of the\n   * emitted event arguments.\n   */ static on(emitter, event) {\n        // deno-lint-ignore no-explicit-any\n        const unconsumedEventValues = [];\n        // deno-lint-ignore no-explicit-any\n        const unconsumedPromises = [];\n        let error = null;\n        let finished = false;\n        const iterator = {\n            // deno-lint-ignore no-explicit-any\n            next () {\n                // First, we consume all unread events\n                // deno-lint-ignore no-explicit-any\n                const value = unconsumedEventValues.shift();\n                if (value) {\n                    return Promise.resolve(createIterResult(value, false));\n                }\n                // Then we error, if an error happened\n                // This happens one time if at all, because after 'error'\n                // we stop listening\n                if (error) {\n                    const p = Promise.reject(error);\n                    // Only the first element errors\n                    error = null;\n                    return p;\n                }\n                // If the iterator is finished, resolve to done\n                if (finished) {\n                    return Promise.resolve(createIterResult(undefined, true));\n                }\n                // Wait until an event happens\n                return new Promise(function(resolve, reject) {\n                    unconsumedPromises.push({\n                        resolve,\n                        reject\n                    });\n                });\n            },\n            // deno-lint-ignore no-explicit-any\n            return () {\n                emitter.removeListener(event, eventHandler);\n                emitter.removeListener(\"error\", errorHandler);\n                finished = true;\n                for (const promise of unconsumedPromises){\n                    promise.resolve(createIterResult(undefined, true));\n                }\n                return Promise.resolve(createIterResult(undefined, true));\n            },\n            throw (err) {\n                error = err;\n                emitter.removeListener(event, eventHandler);\n                emitter.removeListener(\"error\", errorHandler);\n            },\n            // deno-lint-ignore no-explicit-any\n            [Symbol.asyncIterator] () {\n                return this;\n            }\n        };\n        emitter.on(event, eventHandler);\n        emitter.on(\"error\", errorHandler);\n        return iterator;\n        // deno-lint-ignore no-explicit-any\n        function eventHandler(...args) {\n            const promise = unconsumedPromises.shift();\n            if (promise) {\n                promise.resolve(createIterResult(args, false));\n            } else {\n                unconsumedEventValues.push(args);\n            }\n        }\n        // deno-lint-ignore no-explicit-any\n        function errorHandler(err) {\n            finished = true;\n            const toError = unconsumedPromises.shift();\n            if (toError) {\n                toError.reject(err);\n            } else {\n                // The next time we call next()\n                error = err;\n            }\n            iterator.return();\n        }\n    }\n}\nexport default Object.assign(EventEmitter, {\n    EventEmitter\n});\nexport const captureRejectionSymbol = EventEmitter.captureRejectionSymbol;\nexport const errorMonitor = EventEmitter.errorMonitor;\nexport const listenerCount = EventEmitter.listenerCount;\nexport const on = EventEmitter.on;\nexport const once = EventEmitter.once;\n","import { hasJsonStructure, connectWebSocket } from './helpers.ts';\nimport { EventEmitter, v4, websocketEvents } from '../deps.ts';\nexport default class Dropper extends EventEmitter {\n    _socket = null;\n    uri = null;\n    constructor(arg, options){\n        super();\n        this.options = options;\n        this.options = Object.assign({\n            endpoint: '/dropper',\n            uuid: v4.generate()\n        }, this.options);\n        this.uuid = this.options.uuid;\n        this.uri = this.uri = arg ? arg + this.options.endpoint : 'ws://localhost:8080' + this.options.endpoint;\n        connectWebSocket(this.uri, this.uuid).then((socket)=>{\n            this._socket = socket;\n            this.init(this._socket);\n        }).catch((err)=>{\n            console.log(err);\n            this.emit(\"error\", err);\n        });\n    }\n    // Client API\n    async send(evt, data) {\n        let data_push = data ? JSON.stringify({\n            evt,\n            data\n        }) : JSON.stringify(evt);\n        if (this._socket !== null) this._socket.send(data_push);\n    }\n    async broadcast(evt, data) {\n        if (this._socket !== null) {\n            let data_push = data ? {\n                evt,\n                data,\n                client: this.uuid\n            } : {\n                evt: 'message',\n                data: evt,\n                client: this.uuid\n            };\n            let broadcast = JSON.stringify({\n                evt: '_broadcast_',\n                data: data_push\n            });\n            if (this._socket !== null) await this._socket.send(broadcast);\n        }\n    }\n    async close(code = 1005, reason = \"\") {\n        if (this._socket !== null) {\n            return await this._socket.close(code, reason);\n        }\n    }\n    async ping(data) {\n        this?._socket?.send(JSON.stringify({\n            evt: '_ping_',\n            data\n        }));\n    }\n    // Client side handler\n    async init(socket) {\n        this.emit(\"open\");\n        socket.onclose = (ev)=>{\n            const { code , reason  } = ev;\n            this.emit(\"close\", code, reason);\n        };\n        for await (const { data: ev  } of websocketEvents(socket)){\n            try {\n                if (hasJsonStructure(ev)) {\n                    let { evt , data , client  } = JSON.parse(ev);\n                    if (evt == '_ping_') this._socket?.send(JSON.stringify({\n                        evt: '_pong_',\n                        data\n                    }));\n                    if (evt !== '_ping_' && evt !== '_pong_') this.emit(\"_all_\", ev);\n                    if (client !== this.uuid) this.emit(evt, data);\n                } else {\n                    this.emit(\"_all_\", ev);\n                    this.emit('message', ev);\n                }\n            } catch (e) {\n                this.emit(\"error\", e);\n                await this.close(1000);\n            }\n        }\n    }\n};\n","import Dropper from 'https://deno.land/x/dropper@1.10.0/src/browser.ts';\nconst dropper = new Dropper('$$PROTOCOL$$://localhost:$$PORT$$', {\n    endpoint: '/livereload'\n});\ndropper.on('update', ()=>{\n    location.reload();\n});\n"],"names":["v4.generate"],"mappings":"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"}